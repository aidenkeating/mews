// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package imageprocessing

import (
	"image"
	"sync"
)

var (
	lockProcessorPipelineMockAddAction sync.RWMutex
	lockProcessorPipelineMockTransform sync.RWMutex
)

// Ensure, that ProcessorPipelineMock does implement ProcessorPipeline.
// If this is not the case, regenerate this file with moq.
var _ ProcessorPipeline = &ProcessorPipelineMock{}

// ProcessorPipelineMock is a mock implementation of ProcessorPipeline.
//
//     func TestSomethingThatUsesProcessorPipeline(t *testing.T) {
//
//         // make and configure a mocked ProcessorPipeline
//         mockedProcessorPipeline := &ProcessorPipelineMock{
//             AddActionFunc: func(in1 ImageAction)  {
// 	               panic("mock out the AddAction method")
//             },
//             TransformFunc: func(in1 image.Image) (image.Image, error) {
// 	               panic("mock out the Transform method")
//             },
//         }
//
//         // use mockedProcessorPipeline in code that requires ProcessorPipeline
//         // and then make assertions.
//
//     }
type ProcessorPipelineMock struct {
	// AddActionFunc mocks the AddAction method.
	AddActionFunc func(in1 ImageAction)

	// TransformFunc mocks the Transform method.
	TransformFunc func(in1 image.Image) (image.Image, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddAction holds details about calls to the AddAction method.
		AddAction []struct {
			// In1 is the in1 argument value.
			In1 ImageAction
		}
		// Transform holds details about calls to the Transform method.
		Transform []struct {
			// In1 is the in1 argument value.
			In1 image.Image
		}
	}
}

// AddAction calls AddActionFunc.
func (mock *ProcessorPipelineMock) AddAction(in1 ImageAction) {
	if mock.AddActionFunc == nil {
		panic("ProcessorPipelineMock.AddActionFunc: method is nil but ProcessorPipeline.AddAction was just called")
	}
	callInfo := struct {
		In1 ImageAction
	}{
		In1: in1,
	}
	lockProcessorPipelineMockAddAction.Lock()
	mock.calls.AddAction = append(mock.calls.AddAction, callInfo)
	lockProcessorPipelineMockAddAction.Unlock()
	mock.AddActionFunc(in1)
}

// AddActionCalls gets all the calls that were made to AddAction.
// Check the length with:
//     len(mockedProcessorPipeline.AddActionCalls())
func (mock *ProcessorPipelineMock) AddActionCalls() []struct {
	In1 ImageAction
} {
	var calls []struct {
		In1 ImageAction
	}
	lockProcessorPipelineMockAddAction.RLock()
	calls = mock.calls.AddAction
	lockProcessorPipelineMockAddAction.RUnlock()
	return calls
}

// Transform calls TransformFunc.
func (mock *ProcessorPipelineMock) Transform(in1 image.Image) (image.Image, error) {
	if mock.TransformFunc == nil {
		panic("ProcessorPipelineMock.TransformFunc: method is nil but ProcessorPipeline.Transform was just called")
	}
	callInfo := struct {
		In1 image.Image
	}{
		In1: in1,
	}
	lockProcessorPipelineMockTransform.Lock()
	mock.calls.Transform = append(mock.calls.Transform, callInfo)
	lockProcessorPipelineMockTransform.Unlock()
	return mock.TransformFunc(in1)
}

// TransformCalls gets all the calls that were made to Transform.
// Check the length with:
//     len(mockedProcessorPipeline.TransformCalls())
func (mock *ProcessorPipelineMock) TransformCalls() []struct {
	In1 image.Image
} {
	var calls []struct {
		In1 image.Image
	}
	lockProcessorPipelineMockTransform.RLock()
	calls = mock.calls.Transform
	lockProcessorPipelineMockTransform.RUnlock()
	return calls
}
